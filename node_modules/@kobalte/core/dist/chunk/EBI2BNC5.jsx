import {
  useMenuContext,
  useMenuRootContext,
  useOptionalMenubarContext
} from "./HPSNUM3R.jsx";
import {
  ButtonRoot
} from "./SA27V5YJ.jsx";
import {
  createTagName
} from "./CWCB447F.jsx";

// src/menu/menu-trigger.tsx
import {
  callHandler,
  mergeDefaultProps,
  mergeRefs,
  scrollIntoViewport
} from "@kobalte/utils";
import {
  createEffect,
  createMemo,
  onCleanup,
  splitProps
} from "solid-js";
function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = mergeDefaultProps(
    {
      id: rootContext.generateId("trigger")
    },
    props
  );
  const [local, others] = splitProps(mergedProps, [
    "ref",
    "id",
    "disabled",
    "onPointerDown",
    "onClick",
    "onKeyDown",
    "onMouseOver",
    "onFocus"
  ]);
  let key;
  if (optionalMenubarContext !== void 0) {
    key = rootContext.value() ?? local.id;
    createEffect(() => {
      optionalMenubarContext.registerMenu(key, [
        context.contentRef(),
        ...context.nestedMenus()
      ]);
    });
    createEffect(() => {
      if (optionalMenubarContext.value() === key) {
        context.triggerRef()?.focus();
        if (optionalMenubarContext.autoFocusMenu())
          context.open(true);
      } else
        context.close(true);
    });
    createEffect(() => {
      if (context.isOpen())
        optionalMenubarContext.setValue(key);
    });
    onCleanup(() => {
      optionalMenubarContext.unregisterMenu(key);
    });
    if (optionalMenubarContext.lastValue() === void 0)
      optionalMenubarContext.setLastValue(key);
  }
  const tagName = createTagName(
    () => context.triggerRef(),
    () => "button"
  );
  const isNativeLink = createMemo(() => {
    return tagName() === "a" && context.triggerRef()?.getAttribute("href") != null;
  });
  const handleClick = () => {
    optionalMenubarContext?.setAutoFocusMenu(true);
    if (optionalMenubarContext !== void 0)
      context.toggle(false);
    else
      context.toggle(true);
    if (optionalMenubarContext !== void 0 && !context.isOpen() && optionalMenubarContext.value() === key) {
      optionalMenubarContext.closeMenu();
    }
  };
  const onPointerDown = (e) => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      handleClick();
    }
  };
  const onClick = (e) => {
    callHandler(e, local.onClick);
    if (!local.disabled) {
      if (e.currentTarget.dataset.pointerType === "touch")
        handleClick();
    }
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }
    if (isNativeLink()) {
      switch (e.key) {
        case "Enter":
        case " ":
          return;
      }
    }
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        scrollIntoViewport(e.currentTarget);
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowRight":
        if (optionalMenubarContext === void 0)
          break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.nextMenu();
        break;
      case "ArrowLeft":
        if (optionalMenubarContext === void 0)
          break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.previousMenu();
        break;
    }
  };
  const onMouseOver = (e) => {
    callHandler(e, local.onMouseOver);
    if (!local.disabled && optionalMenubarContext !== void 0 && optionalMenubarContext.value() !== void 0) {
      optionalMenubarContext.setValue(key);
    }
  };
  const onFocus = (e) => {
    callHandler(e, local.onFocus);
    if (optionalMenubarContext !== void 0)
      optionalMenubarContext.setValue(key);
  };
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  return <ButtonRoot
    ref={mergeRefs(context.setTriggerRef, local.ref)}
    id={local.id}
    disabled={local.disabled}
    aria-haspopup="true"
    aria-expanded={context.isOpen()}
    aria-controls={context.isOpen() ? context.contentId() : void 0}
    data-highlighted={key !== void 0 && optionalMenubarContext?.value() === key ? true : void 0}
    tabIndex={optionalMenubarContext !== void 0 ? optionalMenubarContext.value() === key || optionalMenubarContext.lastValue() === key ? 0 : -1 : void 0}
    onPointerDown={onPointerDown}
    onMouseOver={onMouseOver}
    onClick={onClick}
    onKeyDown={onKeyDown}
    onFocus={onFocus}
    role={optionalMenubarContext !== void 0 ? "menuitem" : void 0}
    {...context.dataset()}
    {...others}
  />;
}

export {
  MenuTrigger
};
