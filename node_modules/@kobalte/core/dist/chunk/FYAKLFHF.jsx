// src/primitives/create-presence/create-presence.ts
import { createEffect, createSignal, on, onCleanup } from "solid-js";
function createPresence(present) {
  const [node, setNode] = createSignal();
  let styles = {};
  let prevPresent = present();
  let prevAnimationName = "none";
  const [state, send] = createStateMachine(
    present() ? "mounted" : "unmounted",
    {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }
  );
  createEffect(
    on(state, (state2) => {
      const currentAnimationName = getAnimationName(styles);
      prevAnimationName = state2 === "mounted" ? currentAnimationName : "none";
    })
  );
  createEffect(
    on(present, (present2) => {
      if (prevPresent === present2) {
        return;
      }
      const currentAnimationName = getAnimationName(styles);
      if (present2) {
        send("MOUNT");
      } else if (styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (prevPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresent = present2;
    })
  );
  createEffect(
    on(node, (node2) => {
      if (node2) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(styles);
          const isCurrentAnimation = currentAnimationName.includes(
            event.animationName
          );
          if (event.target === node2 && isCurrentAnimation) {
            send("ANIMATION_END");
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node2) {
            prevAnimationName = getAnimationName(styles);
          }
        };
        node2.addEventListener("animationstart", handleAnimationStart);
        node2.addEventListener("animationcancel", handleAnimationEnd);
        node2.addEventListener("animationend", handleAnimationEnd);
        onCleanup(() => {
          node2.removeEventListener("animationstart", handleAnimationStart);
          node2.removeEventListener("animationcancel", handleAnimationEnd);
          node2.removeEventListener("animationend", handleAnimationEnd);
        });
      } else {
        send("ANIMATION_END");
      }
    })
  );
  return {
    isPresent: () => ["mounted", "unmountSuspended"].includes(state()),
    setRef: (el) => {
      if (el) {
        styles = getComputedStyle(el);
      }
      setNode(el);
    }
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function createStateMachine(initialState, machine) {
  const reduce = (state2, event) => {
    const nextState = machine[state2][event];
    return nextState ?? state2;
  };
  const [state, setState] = createSignal(initialState);
  const send = (event) => {
    setState((prev) => reduce(prev, event));
  };
  return [state, send];
}

export {
  createPresence
};
