import { MenuTrigger } from './7X66VFHP.js';
import { MenuCheckboxItem, MenuContent, MenuGroup, MenuGroupLabel, MenuIcon, MenuItem, MenuItemDescription, MenuItemIndicator, MenuItemLabel, MenuPortal, MenuRadioGroup, MenuRadioItem, MenuSub, MenuSubContent, MenuSubTrigger, useMenubarContext, MenuRoot, MenubarContext } from './FEWVDVRO.js';
import { SeparatorRoot } from './QXPEHVJD.js';
import { PopperArrow } from './6SUY5UYD.js';
import { createInteractOutside } from './QGCMYLTA.js';
import { createControllableSignal } from './BLN63FDC.js';
import { Polymorphic } from './SNFWSEOJ.js';
import { __export } from './5ZKAE4VZ.js';
import { createComponent, mergeProps, isServer } from 'solid-js/web';
import { mergeDefaultProps, createGenerateId, contains, mergeRefs } from '@kobalte/utils';
import { splitProps, createUniqueId, createSignal, createMemo, createEffect, onCleanup } from 'solid-js';

// src/menubar/index.tsx
var menubar_exports = {};
__export(menubar_exports, {
  Arrow: () => PopperArrow,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Icon: () => MenuIcon,
  Item: () => MenuItem,
  ItemDescription: () => MenuItemDescription,
  ItemIndicator: () => MenuItemIndicator,
  ItemLabel: () => MenuItemLabel,
  Menu: () => MenubarMenu,
  Menubar: () => Menubar,
  Portal: () => MenuPortal,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  Root: () => MenubarRoot,
  Separator: () => SeparatorRoot,
  Sub: () => MenuSub,
  SubContent: () => MenuSubContent,
  SubTrigger: () => MenuSubTrigger,
  Trigger: () => MenuTrigger
});
function MenubarMenu(props) {
  const menubarContext = useMenubarContext();
  const mergedProps = mergeDefaultProps({
    modal: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["value"]);
  const uniqueid = createUniqueId();
  const defaultId = menubarContext.generateId(`menubar-menu-${uniqueid}`);
  const mergedPropsWithId = mergeDefaultProps({
    id: defaultId
  }, mergedProps);
  return createComponent(MenuRoot, mergeProps({
    get value() {
      return local.value ?? uniqueid;
    }
  }, mergedPropsWithId));
}
function MenubarRoot(props) {
  let ref;
  const defaultId = `menubar-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    loop: true
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "value", "defaultValue", "onValueChange", "loop", "focusOnAlt"]);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: (value2) => local.onValueChange?.(value2)
  });
  const [lastValue, setLastValue] = createSignal();
  const [menuRefs, setMenuRefs] = createSignal(/* @__PURE__ */ new Map());
  const dataset = createMemo(() => ({
    "data-expanded": value() !== void 0 ? "" : void 0,
    "data-closed": value() === void 0 ? "" : void 0
  }));
  const [autoFocusMenu, setAutoFocusMenu] = createSignal(false);
  const context = {
    dataset,
    value,
    setValue,
    lastValue,
    setLastValue,
    menus: () => /* @__PURE__ */ new Set([...menuRefs().keys()]),
    menuRefs: () => [...menuRefs().values()].flat(),
    registerMenu: (value2, refs) => {
      setMenuRefs((prev) => {
        prev.set(value2, refs);
        return prev;
      });
    },
    unregisterMenu: (value2) => {
      setMenuRefs((prev) => {
        prev.delete(value2);
        return prev;
      });
    },
    nextMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === void 0) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === menusArray.length - 1) {
        if (local.loop)
          setValue(menusArray[0]);
        return;
      }
      setValue(menusArray[currentIndex + 1]);
    },
    previousMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === void 0) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === 0) {
        if (local.loop)
          setValue(menusArray[menusArray.length - 1]);
        return;
      }
      setValue(menusArray[currentIndex - 1]);
    },
    closeMenu: () => {
      setAutoFocusMenu(false);
      setValue(void 0);
    },
    autoFocusMenu,
    setAutoFocusMenu,
    generateId: createGenerateId(() => others.id)
  };
  createInteractOutside({
    onInteractOutside: () => {
      context.closeMenu();
    },
    shouldExcludeElement: (element) => {
      return [ref, ...menuRefs().values()].flat().some((ref2) => contains(ref2, element));
    }
  }, () => ref);
  const keydownHandler = (e) => {
    if (e.key === "Alt") {
      e.preventDefault();
      e.stopPropagation();
      if (context.value() === void 0)
        context.nextMenu();
      else
        context.closeMenu();
    }
  };
  createEffect(() => {
    if (isServer)
      return;
    if (local.focusOnAlt)
      window.addEventListener("keydown", keydownHandler);
    else
      window.removeEventListener("keydown", keydownHandler);
  });
  createEffect(() => {
    if (value() !== void 0)
      setLastValue(value());
  });
  onCleanup(() => {
    if (isServer)
      return;
    window.removeEventListener("keydown", keydownHandler);
  });
  return createComponent(MenubarContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = mergeRefs((el) => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "menubar",
        "data-orientation": "horizontal"
      }, others));
    }
  });
}

// src/menubar/index.tsx
var Menubar = Object.assign(MenubarRoot, {
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: MenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Menu: MenubarMenu,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: MenuTrigger
});

export { Menubar, MenubarMenu, MenubarRoot, menubar_exports };
