import {
  MenuTrigger
} from "./EBI2BNC5.jsx";
import {
  MenuCheckboxItem,
  MenuContent,
  MenuGroup,
  MenuGroupLabel,
  MenuIcon,
  MenuItem,
  MenuItemDescription,
  MenuItemIndicator,
  MenuItemLabel,
  MenuPortal,
  MenuRadioGroup,
  MenuRadioItem,
  MenuRoot,
  MenuSub,
  MenuSubContent,
  MenuSubTrigger,
  MenubarContext,
  useMenubarContext
} from "./HPSNUM3R.jsx";
import {
  SeparatorRoot
} from "./7PY7PKWO.jsx";
import {
  PopperArrow
} from "./M2VB7IWQ.jsx";
import {
  createInteractOutside
} from "./BMMCQ7YJ.jsx";
import {
  createControllableSignal
} from "./FN6EICGO.jsx";
import {
  Polymorphic
} from "./E73PKFB3.jsx";
import {
  __export
} from "./5WXHJDCZ.jsx";

// src/menubar/index.tsx
var menubar_exports = {};
__export(menubar_exports, {
  Arrow: () => PopperArrow,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Icon: () => MenuIcon,
  Item: () => MenuItem,
  ItemDescription: () => MenuItemDescription,
  ItemIndicator: () => MenuItemIndicator,
  ItemLabel: () => MenuItemLabel,
  Menu: () => MenubarMenu,
  Menubar: () => Menubar,
  Portal: () => MenuPortal,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  Root: () => MenubarRoot,
  Separator: () => SeparatorRoot,
  Sub: () => MenuSub,
  SubContent: () => MenuSubContent,
  SubTrigger: () => MenuSubTrigger,
  Trigger: () => MenuTrigger
});

// src/menubar/menubar-menu.tsx
import { mergeDefaultProps } from "@kobalte/utils";
import { createUniqueId, splitProps } from "solid-js";
function MenubarMenu(props) {
  const menubarContext = useMenubarContext();
  const mergedProps = mergeDefaultProps(
    {
      modal: false
    },
    props
  );
  const [local, others] = splitProps(mergedProps, ["value"]);
  const uniqueid = createUniqueId();
  const defaultId = menubarContext.generateId(`menubar-menu-${uniqueid}`);
  const mergedPropsWithId = mergeDefaultProps({ id: defaultId }, mergedProps);
  return <MenuRoot value={local.value ?? uniqueid} {...mergedPropsWithId} />;
}

// src/menubar/menubar-root.tsx
import {
  contains,
  createGenerateId,
  mergeDefaultProps as mergeDefaultProps2,
  mergeRefs
} from "@kobalte/utils";
import {
  createEffect,
  createMemo,
  createSignal,
  createUniqueId as createUniqueId2,
  onCleanup,
  splitProps as splitProps2
} from "solid-js";
import { isServer } from "solid-js/web";
function MenubarRoot(props) {
  let ref;
  const defaultId = `menubar-${createUniqueId2()}`;
  const mergedProps = mergeDefaultProps2(
    { id: defaultId, loop: true },
    props
  );
  const [local, others] = splitProps2(mergedProps, [
    "ref",
    "value",
    "defaultValue",
    "onValueChange",
    "loop",
    "focusOnAlt"
  ]);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: (value2) => local.onValueChange?.(value2)
  });
  const [lastValue, setLastValue] = createSignal();
  const [menuRefs, setMenuRefs] = createSignal(
    /* @__PURE__ */ new Map()
  );
  const dataset = createMemo(() => ({
    "data-expanded": value() !== void 0 ? "" : void 0,
    "data-closed": value() === void 0 ? "" : void 0
  }));
  const [autoFocusMenu, setAutoFocusMenu] = createSignal(false);
  const context = {
    dataset,
    value,
    setValue,
    lastValue,
    setLastValue,
    menus: () => /* @__PURE__ */ new Set([...menuRefs().keys()]),
    menuRefs: () => [...menuRefs().values()].flat(),
    registerMenu: (value2, refs) => {
      setMenuRefs((prev) => {
        prev.set(value2, refs);
        return prev;
      });
    },
    unregisterMenu: (value2) => {
      setMenuRefs((prev) => {
        prev.delete(value2);
        return prev;
      });
    },
    nextMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === void 0) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === menusArray.length - 1) {
        if (local.loop)
          setValue(menusArray[0]);
        return;
      }
      setValue(menusArray[currentIndex + 1]);
    },
    previousMenu: () => {
      const menusArray = [...menuRefs().keys()];
      if (value() === void 0) {
        setValue(menusArray[0]);
        return;
      }
      const currentIndex = menusArray.indexOf(value());
      if (currentIndex === 0) {
        if (local.loop)
          setValue(menusArray[menusArray.length - 1]);
        return;
      }
      setValue(menusArray[currentIndex - 1]);
    },
    closeMenu: () => {
      setAutoFocusMenu(false);
      setValue(void 0);
    },
    autoFocusMenu,
    setAutoFocusMenu,
    generateId: createGenerateId(() => others.id)
  };
  createInteractOutside(
    {
      onInteractOutside: () => {
        context.closeMenu();
      },
      shouldExcludeElement: (element) => {
        return [ref, ...menuRefs().values()].flat().some((ref2) => contains(ref2, element));
      }
    },
    () => ref
  );
  const keydownHandler = (e) => {
    if (e.key === "Alt") {
      e.preventDefault();
      e.stopPropagation();
      if (context.value() === void 0)
        context.nextMenu();
      else
        context.closeMenu();
    }
  };
  createEffect(() => {
    if (isServer)
      return;
    if (local.focusOnAlt)
      window.addEventListener("keydown", keydownHandler);
    else
      window.removeEventListener("keydown", keydownHandler);
  });
  createEffect(() => {
    if (value() !== void 0)
      setLastValue(value());
  });
  onCleanup(() => {
    if (isServer)
      return;
    window.removeEventListener("keydown", keydownHandler);
  });
  return <MenubarContext.Provider value={context}><Polymorphic
    as="div"
    ref={mergeRefs((el) => ref = el, local.ref)}
    role="menubar"
    data-orientation="horizontal"
    {...others}
  /></MenubarContext.Provider>;
}

// src/menubar/index.tsx
var Menubar = Object.assign(MenubarRoot, {
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: MenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Menu: MenubarMenu,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: MenuTrigger
});

export {
  MenubarMenu,
  MenubarRoot,
  Menubar,
  menubar_exports
};
