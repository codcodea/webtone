import { useMenuRootContext, useMenuContext, useOptionalMenubarContext } from './FEWVDVRO.js';
import { ButtonRoot } from './EOS4KX3P.js';
import { createTagName } from './3QD537TT.js';
import { createComponent, mergeProps, memo } from 'solid-js/web';
import { mergeDefaultProps, mergeRefs, callHandler, scrollIntoViewport } from '@kobalte/utils';
import { splitProps, createEffect, onCleanup, createMemo } from 'solid-js';

function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "disabled", "onPointerDown", "onClick", "onKeyDown", "onMouseOver", "onFocus"]);
  let key;
  if (optionalMenubarContext !== void 0) {
    key = rootContext.value() ?? local.id;
    createEffect(() => {
      optionalMenubarContext.registerMenu(key, [context.contentRef(), ...context.nestedMenus()]);
    });
    createEffect(() => {
      if (optionalMenubarContext.value() === key) {
        context.triggerRef()?.focus();
        if (optionalMenubarContext.autoFocusMenu())
          context.open(true);
      } else
        context.close(true);
    });
    createEffect(() => {
      if (context.isOpen())
        optionalMenubarContext.setValue(key);
    });
    onCleanup(() => {
      optionalMenubarContext.unregisterMenu(key);
    });
    if (optionalMenubarContext.lastValue() === void 0)
      optionalMenubarContext.setLastValue(key);
  }
  const tagName = createTagName(() => context.triggerRef(), () => "button");
  const isNativeLink = createMemo(() => {
    return tagName() === "a" && context.triggerRef()?.getAttribute("href") != null;
  });
  const handleClick = () => {
    optionalMenubarContext?.setAutoFocusMenu(true);
    if (optionalMenubarContext !== void 0)
      context.toggle(false);
    else
      context.toggle(true);
    if (optionalMenubarContext !== void 0 && !context.isOpen() && optionalMenubarContext.value() === key) {
      optionalMenubarContext.closeMenu();
    }
  };
  const onPointerDown = (e) => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      handleClick();
    }
  };
  const onClick = (e) => {
    callHandler(e, local.onClick);
    if (!local.disabled) {
      if (e.currentTarget.dataset.pointerType === "touch")
        handleClick();
    }
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }
    if (isNativeLink()) {
      switch (e.key) {
        case "Enter":
        case " ":
          return;
      }
    }
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        scrollIntoViewport(e.currentTarget);
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowRight":
        if (optionalMenubarContext === void 0)
          break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.nextMenu();
        break;
      case "ArrowLeft":
        if (optionalMenubarContext === void 0)
          break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.previousMenu();
        break;
    }
  };
  const onMouseOver = (e) => {
    callHandler(e, local.onMouseOver);
    if (!local.disabled && optionalMenubarContext !== void 0 && optionalMenubarContext.value() !== void 0) {
      optionalMenubarContext.setValue(key);
    }
  };
  const onFocus = (e) => {
    callHandler(e, local.onFocus);
    if (optionalMenubarContext !== void 0)
      optionalMenubarContext.setValue(key);
  };
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  return createComponent(ButtonRoot, mergeProps({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get disabled() {
      return local.disabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : void 0;
    },
    get ["data-highlighted"]() {
      return key !== void 0 && optionalMenubarContext?.value() === key ? true : void 0;
    },
    get tabIndex() {
      return optionalMenubarContext !== void 0 ? optionalMenubarContext.value() === key || optionalMenubarContext.lastValue() === key ? 0 : -1 : void 0;
    },
    onPointerDown,
    onMouseOver,
    onClick,
    onKeyDown,
    onFocus,
    role: optionalMenubarContext !== void 0 ? "menuitem" : void 0
  }, () => context.dataset(), others));
}

export { MenuTrigger };
